public class KokoEatingBananas {
   /*
Koko Eating Bananas Problem Statement 

Koko loves to eat bananas.

She has several piles of bananas
Example: [3, 6, 7, 11]

She has H hours to eat all the bananas
Example: H = 8



Every hour, Koko chooses only one pile

She eats K bananas per hour (same speed every hour)

Question:
What is the minimum eating speed K so that Koko can finish all bananas within H hours?

Key Observations

If K is small, Koko eats slowly → needs more hours 

If K is large, Koko eats faster → needs fewer hours 

We want the minimum possible K that still works

Why Binary Search?

Minimum speed = 1 banana/hour

Maximum speed = max number of bananas in a pile

The answer lies between 1 and max pile, and:

As speed increases, total time required decreases

This makes the search space monotonic, which is perfect for Binary Search.

Example 1:

Input: piles = [3,6,7,11], h = 8
Output: 4
Example 2:

Input: piles = [30,11,23,4,20], h = 5
Output: 30
Example 3:

Input: piles = [30,11,23,4,20], h = 6
Output: 23
   
   
   
   
   */



    public static void main(String[] args){
        int[] piles = {30,11,23,4,20};
        int H = 6 ; 

        int lower = 1 ; 
        int higher = getMax(piles);
        int answer = higher;

        while(lower<=higher){


            int mid = lower+(higher-lower)/2;

            if(canFinish(piles, mid, H)){

                answer = mid;
                higher = mid-1;


            }else{

                lower = mid+1;
            }



        }

        System.out.println("Minimum capacity : "+answer);






        
    }

    public static boolean canFinish(int[] piles, int speed, int h) {
        int time = 0;
        // pile = 7 , k = 3 , 1 - 3 , 2 -3 , 3 - 1 , 7/3 = 2 , pile/speed
    
        for (int pile : piles) {
            time += (pile + speed - 1) / speed;
        }
        return time <= h;
    }



    public static int getMax(int[] piles){

        int max = 0 ;

        for(int pile:piles){
            max = Math.max(max, pile);
        }

        return max;

    }
}
